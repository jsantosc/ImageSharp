// <autogenerated />
// <copyright file="PorterDuffFunctions.Generated.cs" company="James Jackson-South">
// Copyright (c) James Jackson-South and contributors.
// Licensed under the Apache License, Version 2.0.
// </copyright>

namespace ImageSharp.PixelFormats.PixelBlenders
{
    using System.Numerics;
    using System.Runtime.CompilerServices;


    internal static partial class PorterDuffFunctions
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector4 Src(Vector4 backdrop, Vector4 source, float opacity)
        {
            opacity = opacity.Clamp(0, 1);
            source.W *= opacity;            
            Vector4 xform = source;

            // calculate weights
            float xw = Vector4.Zero.W * source.W;
            float bw = Vector4.Zero.W - xw;
            float sw = source.W - xw;

            // calculate final alpha
            float a = xw + bw + sw;

            // calculate final value
            xform = ((xform * xw) + (Vector4.Zero * bw) + (source * sw)) / MathF.Max(a, Constants.Epsilon);

            return Vector4.Lerp(backdrop, xform, opacity);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector4 Atop(Vector4 backdrop, Vector4 source, float opacity)
        {
            opacity = opacity.Clamp(0, 1);
            Vector4 xform = source;

            // calculate weights
            float xw = backdrop.W * Vector4.Zero.W;
            float bw = backdrop.W - xw;
            float sw = Vector4.Zero.W - xw;

            // calculate final alpha
            float a = xw + bw + sw;

            // calculate final value
            xform = ((xform * xw) + (backdrop * bw) + (Vector4.Zero * sw)) / MathF.Max(a, Constants.Epsilon);

            return Vector4.Lerp(backdrop, xform, opacity);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector4 Over(Vector4 backdrop, Vector4 source, float opacity)
        {
            opacity = opacity.Clamp(0, 1);
            source.W *= opacity;            
            Vector4 xform = source;

            // calculate weights
            float xw = backdrop.W * source.W;
            float bw = backdrop.W - xw;
            float sw = source.W - xw;

            // calculate final alpha
            float a = xw + bw + sw;

            // calculate final value
            xform = ((xform * xw) + (backdrop * bw) + (source * sw)) / MathF.Max(a, Constants.Epsilon);

            return Vector4.Lerp(backdrop, xform, opacity);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector4 In(Vector4 backdrop, Vector4 source, float opacity)
        {
            opacity = opacity.Clamp(0, 1);
            Vector4 xform = source;

            // calculate weights
            float xw = Vector4.Zero.W * Vector4.Zero.W;
            float bw = Vector4.Zero.W - xw;
            float sw = Vector4.Zero.W - xw;

            // calculate final alpha
            float a = xw + bw + sw;

            // calculate final value
            xform = ((xform * xw) + (Vector4.Zero * bw) + (Vector4.Zero * sw)) / MathF.Max(a, Constants.Epsilon);

            return Vector4.Lerp(backdrop, xform, opacity);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector4 Out(Vector4 backdrop, Vector4 source, float opacity)
        {
            opacity = opacity.Clamp(0, 1);
            source.W *= opacity;            
            Vector4 xform = Vector4.Zero;

            // calculate weights
            float xw = Vector4.Zero.W * source.W;
            float bw = Vector4.Zero.W - xw;
            float sw = source.W - xw;

            // calculate final alpha
            float a = xw + bw + sw;

            // calculate final value
            xform = ((xform * xw) + (Vector4.Zero * bw) + (source * sw)) / MathF.Max(a, Constants.Epsilon);

            return Vector4.Lerp(backdrop, xform, opacity);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector4 Dest(Vector4 backdrop, Vector4 source, float opacity)
        {
            opacity = opacity.Clamp(0, 1);
            Vector4 xform = backdrop;

            // calculate weights
            float xw = backdrop.W * Vector4.Zero.W;
            float bw = backdrop.W - xw;
            float sw = Vector4.Zero.W - xw;

            // calculate final alpha
            float a = xw + bw + sw;

            // calculate final value
            xform = ((xform * xw) + (backdrop * bw) + (Vector4.Zero * sw)) / MathF.Max(a, Constants.Epsilon);

            return Vector4.Lerp(backdrop, xform, opacity);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector4 DestAtop(Vector4 backdrop, Vector4 source, float opacity)
        {
            opacity = opacity.Clamp(0, 1);
            source.W *= opacity;            
            Vector4 xform = backdrop;

            // calculate weights
            float xw = Vector4.Zero.W * source.W;
            float bw = Vector4.Zero.W - xw;
            float sw = source.W - xw;

            // calculate final alpha
            float a = xw + bw + sw;

            // calculate final value
            xform = ((xform * xw) + (Vector4.Zero * bw) + (source * sw)) / MathF.Max(a, Constants.Epsilon);

            return Vector4.Lerp(backdrop, xform, opacity);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector4 DestOver(Vector4 backdrop, Vector4 source, float opacity)
        {
            opacity = opacity.Clamp(0, 1);
            source.W *= opacity;            
            Vector4 xform = backdrop;

            // calculate weights
            float xw = backdrop.W * source.W;
            float bw = backdrop.W - xw;
            float sw = source.W - xw;

            // calculate final alpha
            float a = xw + bw + sw;

            // calculate final value
            xform = ((xform * xw) + (backdrop * bw) + (source * sw)) / MathF.Max(a, Constants.Epsilon);

            return Vector4.Lerp(backdrop, xform, opacity);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector4 DestIn(Vector4 backdrop, Vector4 source, float opacity)
        {
            opacity = opacity.Clamp(0, 1);
            Vector4 xform = backdrop;

            // calculate weights
            float xw = Vector4.Zero.W * Vector4.Zero.W;
            float bw = Vector4.Zero.W - xw;
            float sw = Vector4.Zero.W - xw;

            // calculate final alpha
            float a = xw + bw + sw;

            // calculate final value
            xform = ((xform * xw) + (Vector4.Zero * bw) + (Vector4.Zero * sw)) / MathF.Max(a, Constants.Epsilon);

            return Vector4.Lerp(backdrop, xform, opacity);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector4 DestOut(Vector4 backdrop, Vector4 source, float opacity)
        {
            opacity = opacity.Clamp(0, 1);
            Vector4 xform = Vector4.Zero;

            // calculate weights
            float xw = backdrop.W * Vector4.Zero.W;
            float bw = backdrop.W - xw;
            float sw = Vector4.Zero.W - xw;

            // calculate final alpha
            float a = xw + bw + sw;

            // calculate final value
            xform = ((xform * xw) + (backdrop * bw) + (Vector4.Zero * sw)) / MathF.Max(a, Constants.Epsilon);

            return Vector4.Lerp(backdrop, xform, opacity);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector4 Clear(Vector4 backdrop, Vector4 source, float opacity)
        {
            opacity = opacity.Clamp(0, 1);
            Vector4 xform = Vector4.Zero;

            // calculate weights
            float xw = Vector4.Zero.W * Vector4.Zero.W;
            float bw = Vector4.Zero.W - xw;
            float sw = Vector4.Zero.W - xw;

            // calculate final alpha
            float a = xw + bw + sw;

            // calculate final value
            xform = ((xform * xw) + (Vector4.Zero * bw) + (Vector4.Zero * sw)) / MathF.Max(a, Constants.Epsilon);

            return Vector4.Lerp(backdrop, xform, opacity);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector4 Xor(Vector4 backdrop, Vector4 source, float opacity)
        {
            opacity = opacity.Clamp(0, 1);
            source.W *= opacity;            
            Vector4 xform = Vector4.Zero;

            // calculate weights
            float xw = backdrop.W * source.W;
            float bw = backdrop.W - xw;
            float sw = source.W - xw;

            // calculate final alpha
            float a = xw + bw + sw;

            // calculate final value
            xform = ((xform * xw) + (backdrop * bw) + (source * sw)) / MathF.Max(a, Constants.Epsilon);

            return Vector4.Lerp(backdrop, xform, opacity);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TPixel Normal<TPixel>(TPixel backdrop, TPixel source, float amount)
            where TPixel : struct, IPixel<TPixel>
        {
            TPixel dest = default(TPixel);
            dest.PackFromVector4(Normal(backdrop.ToVector4(), source.ToVector4(), amount));
            return dest;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TPixel Multiply<TPixel>(TPixel backdrop, TPixel source, float amount)
            where TPixel : struct, IPixel<TPixel>
        {
            TPixel dest = default(TPixel);
            dest.PackFromVector4(Multiply(backdrop.ToVector4(), source.ToVector4(), amount));
            return dest;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TPixel Add<TPixel>(TPixel backdrop, TPixel source, float amount)
            where TPixel : struct, IPixel<TPixel>
        {
            TPixel dest = default(TPixel);
            dest.PackFromVector4(Add(backdrop.ToVector4(), source.ToVector4(), amount));
            return dest;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TPixel Substract<TPixel>(TPixel backdrop, TPixel source, float amount)
            where TPixel : struct, IPixel<TPixel>
        {
            TPixel dest = default(TPixel);
            dest.PackFromVector4(Substract(backdrop.ToVector4(), source.ToVector4(), amount));
            return dest;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TPixel Screen<TPixel>(TPixel backdrop, TPixel source, float amount)
            where TPixel : struct, IPixel<TPixel>
        {
            TPixel dest = default(TPixel);
            dest.PackFromVector4(Screen(backdrop.ToVector4(), source.ToVector4(), amount));
            return dest;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TPixel Darken<TPixel>(TPixel backdrop, TPixel source, float amount)
            where TPixel : struct, IPixel<TPixel>
        {
            TPixel dest = default(TPixel);
            dest.PackFromVector4(Darken(backdrop.ToVector4(), source.ToVector4(), amount));
            return dest;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TPixel Lighten<TPixel>(TPixel backdrop, TPixel source, float amount)
            where TPixel : struct, IPixel<TPixel>
        {
            TPixel dest = default(TPixel);
            dest.PackFromVector4(Lighten(backdrop.ToVector4(), source.ToVector4(), amount));
            return dest;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TPixel Overlay<TPixel>(TPixel backdrop, TPixel source, float amount)
            where TPixel : struct, IPixel<TPixel>
        {
            TPixel dest = default(TPixel);
            dest.PackFromVector4(Overlay(backdrop.ToVector4(), source.ToVector4(), amount));
            return dest;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TPixel HardLight<TPixel>(TPixel backdrop, TPixel source, float amount)
            where TPixel : struct, IPixel<TPixel>
        {
            TPixel dest = default(TPixel);
            dest.PackFromVector4(HardLight(backdrop.ToVector4(), source.ToVector4(), amount));
            return dest;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TPixel Src<TPixel>(TPixel backdrop, TPixel source, float amount)
            where TPixel : struct, IPixel<TPixel>
        {
            TPixel dest = default(TPixel);
            dest.PackFromVector4(Src(backdrop.ToVector4(), source.ToVector4(), amount));
            return dest;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TPixel Atop<TPixel>(TPixel backdrop, TPixel source, float amount)
            where TPixel : struct, IPixel<TPixel>
        {
            TPixel dest = default(TPixel);
            dest.PackFromVector4(Atop(backdrop.ToVector4(), source.ToVector4(), amount));
            return dest;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TPixel Over<TPixel>(TPixel backdrop, TPixel source, float amount)
            where TPixel : struct, IPixel<TPixel>
        {
            TPixel dest = default(TPixel);
            dest.PackFromVector4(Over(backdrop.ToVector4(), source.ToVector4(), amount));
            return dest;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TPixel In<TPixel>(TPixel backdrop, TPixel source, float amount)
            where TPixel : struct, IPixel<TPixel>
        {
            TPixel dest = default(TPixel);
            dest.PackFromVector4(In(backdrop.ToVector4(), source.ToVector4(), amount));
            return dest;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TPixel Out<TPixel>(TPixel backdrop, TPixel source, float amount)
            where TPixel : struct, IPixel<TPixel>
        {
            TPixel dest = default(TPixel);
            dest.PackFromVector4(Out(backdrop.ToVector4(), source.ToVector4(), amount));
            return dest;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TPixel Dest<TPixel>(TPixel backdrop, TPixel source, float amount)
            where TPixel : struct, IPixel<TPixel>
        {
            TPixel dest = default(TPixel);
            dest.PackFromVector4(Dest(backdrop.ToVector4(), source.ToVector4(), amount));
            return dest;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TPixel DestAtop<TPixel>(TPixel backdrop, TPixel source, float amount)
            where TPixel : struct, IPixel<TPixel>
        {
            TPixel dest = default(TPixel);
            dest.PackFromVector4(DestAtop(backdrop.ToVector4(), source.ToVector4(), amount));
            return dest;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TPixel DestOver<TPixel>(TPixel backdrop, TPixel source, float amount)
            where TPixel : struct, IPixel<TPixel>
        {
            TPixel dest = default(TPixel);
            dest.PackFromVector4(DestOver(backdrop.ToVector4(), source.ToVector4(), amount));
            return dest;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TPixel DestIn<TPixel>(TPixel backdrop, TPixel source, float amount)
            where TPixel : struct, IPixel<TPixel>
        {
            TPixel dest = default(TPixel);
            dest.PackFromVector4(DestIn(backdrop.ToVector4(), source.ToVector4(), amount));
            return dest;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TPixel DestOut<TPixel>(TPixel backdrop, TPixel source, float amount)
            where TPixel : struct, IPixel<TPixel>
        {
            TPixel dest = default(TPixel);
            dest.PackFromVector4(DestOut(backdrop.ToVector4(), source.ToVector4(), amount));
            return dest;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TPixel Clear<TPixel>(TPixel backdrop, TPixel source, float amount)
            where TPixel : struct, IPixel<TPixel>
        {
            TPixel dest = default(TPixel);
            dest.PackFromVector4(Clear(backdrop.ToVector4(), source.ToVector4(), amount));
            return dest;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TPixel Xor<TPixel>(TPixel backdrop, TPixel source, float amount)
            where TPixel : struct, IPixel<TPixel>
        {
            TPixel dest = default(TPixel);
            dest.PackFromVector4(Xor(backdrop.ToVector4(), source.ToVector4(), amount));
            return dest;
        }

    }
}