<#
// <copyright file="PixelOperations{TPixel}.Generated.tt" company="James Jackson-South">
// Copyright (c) James Jackson-South and contributors.
// Licensed under the Apache License, Version 2.0.
// </copyright>
#>
<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#    
    void GenerateToDestFormatMethods(string pixelType)
    {
        #>

		/// <summary>
        /// Converts 'count' pixels in 'sourcePixels` span to a span of <see cref="<#=pixelType#>"/>-s.
        /// Bulk version of <see cref="IPixel.To<#=pixelType#>(ref <#=pixelType#>)"/>.
        /// </summary>
        /// <param name="sourcePixels">The span of source pixels</param>
        /// <param name="dest">The destination span of <see cref="<#=pixelType#>"/> data.</param>
        /// <param name="count">The number of pixels to convert.</param>
        internal virtual void To<#=pixelType#>(Span<TPixel> sourcePixels, Span<<#=pixelType#>> dest, int count)
        {
            GuardSpans(sourcePixels, nameof(sourcePixels), dest, nameof(dest), count);

            ref TPixel sourceBaseRef = ref sourcePixels.DangerousGetPinnableReference();
            ref <#=pixelType#> destBaseRef = ref dest.DangerousGetPinnableReference();

            for (int i = 0; i < count; i++)
            {
                ref TPixel sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref <#=pixelType#> dp = ref Unsafe.Add(ref destBaseRef, i);
                sp.To<#=pixelType#>(ref dp);
            }
        }

		/// <summary>
        /// A helper for <see cref="To<#=pixelType#>(Span{TPixel}, Span{<#=pixelType#>}, int)"/> that expects a byte span as destination.
        /// The layout of the data in 'destBytes' must be compatible with <see cref="<#=pixelType#>"/> layout.
        /// </summary>
        /// <param name="sourceColors">The <see cref="Span{T}"/> to the source colors.</param>
        /// <param name="destBytes">The <see cref="Span{T}"/> to the destination bytes.</param>
        /// <param name="count">The number of pixels to convert.</param>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void To<#=pixelType#>Bytes(Span<TPixel> sourceColors, Span<byte> destBytes, int count)
        {
            this.To<#=pixelType#>(sourceColors, destBytes.NonPortableCast<byte, <#=pixelType#>>(), count);
        }
		<#
    }

    void GeneratePackFromMethodUsingPackFromRgba32(string pixelType, string rgbaOperationCode)
    {		
		#>

		/// <summary>
        /// Converts 'count' elements in 'source` span of <see cref="<#=pixelType#>"/> data to a span of <typeparamref name="TPixel"/>-s.
        /// </summary>
        /// <param name="source">The source <see cref="Span{T}"/> of <see cref="<#=pixelType#>"/> data.</param>
        /// <param name="destPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        /// <param name="count">The number of pixels to convert.</param>
        internal virtual void PackFrom<#=pixelType#>(Span<<#=pixelType#>> source, Span<TPixel> destPixels, int count)
        {
			GuardSpans(source, nameof(source), destPixels, nameof(destPixels), count);
            
            ref <#=pixelType#> sourceRef = ref source.DangerousGetPinnableReference();
            ref TPixel destRef = ref destPixels.DangerousGetPinnableReference();

            Rgba32 rgba = new Rgba32(0, 0, 0, 255);

            for (int i = 0; i < count; i++)
            {
                ref TPixel dp = ref Unsafe.Add(ref destRef, i);
                <#=rgbaOperationCode#>
				dp.PackFromRgba32(rgba);
            }
        }
		
		/// <summary>
        /// A helper for <see cref="PackFrom<#=pixelType#>(Span{<#=pixelType#>}, Span{TPixel}, int)"/> that expects a byte span.
        /// The layout of the data in 'sourceBytes' must be compatible with <see cref="<#=pixelType#>"/> layout.
        /// </summary>
        /// <param name="sourceBytes">The <see cref="Span{T}"/> to the source bytes.</param>
        /// <param name="destPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void PackFrom<#=pixelType#>Bytes(Span<byte> sourceBytes, Span<TPixel> destPixels, int count)
        {
            this.PackFrom<#=pixelType#>(sourceBytes.NonPortableCast<byte, <#=pixelType#>>(), destPixels, count);
        }
		<#
    }

#>
// <auto-generated />

// <copyright file="PixelOperations{TPixel}.Generated.cs" company="James Jackson-South">
// Copyright (c) James Jackson-South and contributors.
// Licensed under the Apache License, Version 2.0.
// </copyright>

namespace ImageSharp.PixelFormats
{
    using System;
    using System.Numerics;
    using System.Runtime.CompilerServices;
	    
    public partial class PixelOperations<TPixel>
    {
		<#

    GeneratePackFromMethodUsingPackFromRgba32("Rgba32", "rgba = Unsafe.Add(ref sourceRef, i);");
    GenerateToDestFormatMethods("Rgba32");

    GeneratePackFromMethodUsingPackFromRgba32("Bgra32", "rgba = Unsafe.Add(ref sourceRef, i).ToRgba32();");
    GenerateToDestFormatMethods("Bgra32");
	
	GeneratePackFromMethodUsingPackFromRgba32("Rgb24", "rgba.Rgb = Unsafe.Add(ref sourceRef, i);");
    GenerateToDestFormatMethods("Rgb24");

    GeneratePackFromMethodUsingPackFromRgba32("Bgr24", "rgba.Bgr = Unsafe.Add(ref sourceRef, i);");
    GenerateToDestFormatMethods("Bgr24");

		#>

	}
}